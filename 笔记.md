# 数据存储问题与解决方案

## 存在问题

1. **数据存储问题**：这里是将每个图表的原始数据存储到了同一个数据表中的 `chartData` 字段，如果用户上传的原始数据很大，图表日益增多，会导致数据库存储的数据量过大，会导致数据库性能下降，甚至数据库崩溃。

2. **查询性能问题**：用户有查询原始数据的需求，现在如果把所有数据存在一个表的字段中，那么每次都会取出全部数据，性能比较低。

## 解决方案：分库分表

- **水平分库**、**垂直分表**

### 方案描述

将每个图表数据存储到单独的表中，用户查询的时候，根据图表 id 查询对应的数据，使用 MongoDB。

### 优点

1. 存储时分开，互不影响，也能增加安全性
2. 查询时，可以根据各种 SQL 语句灵活取用需要的字段，性能更高

### 实现方式

#### 方式一：MongoDB
创建一个 MongoDB 数据库，创建一个 collection，将每个图表的数据存储到这个 collection 中，根据图表 id 查询数据

#### 方式二：MySQL
使用 MySQL，创建一个表，将每个图表的数据存储到这个表中，根据图表 id 查询数据，表名设置为 `chart_图表id`

## 限流算法

### 现存问题

使用系统是有消耗成本的，用户有可能疯狂刷量，让你破产

### 解决方案

1. 限制用户调用总次数，控制成本
2. 用户在短时间内疯狂使用，导致服务器资源被占满，其他用户无法使用 → 限流算法

### 核心问题

限流阈值多大比较合适？比如限制单个用户在每秒只能使用1次

### 限流算法类型

1. **固定窗口限流**
   - **原理**：单位时间内允许部分操作，1小时只允许10个用户操作
   - **优点**：实现最简单
   - **缺点**：可能出现流量突刺。比如前59分钟内，用户访问量只有1个，但是第60分钟的用户访问量却有10个，那么就会导致用户访问量暴增，导致服务器压力过大，用户访问失败，服务器仍然有高峰。

2. **滑动窗口限流**
   - **原理**：在时间区间内平滑控制请求次数
   - **优点**：不会出现流量突刺，1个小时的时间段内只能访问10个请求
   - **缺点**：相对复杂，限流效果和滑动单位有关，滑动单位越小，限流效果越高，但是往往很难选到一个最合适的滑动单位

3. **漏桶限流**
   - **原理**：以固定的速度处理请求，当请求桶满了后拒绝请求。每秒处理10个请求，桶的容量是10，每0.1秒处理1个请求，如果10秒内只有10个请求，那么都能处理，如果是11个，桶就会溢出，那么最后一个会被拒绝
   - **优点**：能够一定程度上应对流量突刺
   - **缺点**：没办法迅速处理一批请求，只能一个一个按顺序来处理（固定速率的缺点）

4. **令牌桶限流**
   - **原理**：管理员先生产一批令牌，每秒生成10个；当用户要操作时，先去拿到一个令牌，有令牌的就有资格去操作，能够同时执行操作；拿不到令牌就等待
   - **优点**：能并发处理同时的请求，并发性能高
   - **缺点**：还是存在时间单位选取问题，时间单位小了，

### 限流的粒度

1. 针对某个方法限流，即单位时间内最多允许同时XX个操作使用这个方法
2. 针对某个限流，比如单个用户单位时间内最多执行XX次操作

### 限流实现方式

#### 1. 本地限流（单机限流）
每个服务器单独限流，一般适用于单体项目，就是你的项目只有一个服务器

#### 2. 分布式限流（多机限流）
- Redisson集中统计用户频率数据限流
- 网关集中限流和统计（Sentinel、Spring Cloud Gateway）

## 异步化

- **同步**：做完一件事后再去做另外一件事
- **异步**：不用等一件事做完，就可以做另外一件事，比如将热水器打开烧水，设置100度会发出通知提醒，然后去做另外一件事，烧水时人可以同时处理别的事，水烧好后，人能收到通知，就知道水烧好了。

### 业务流程分析

#### 标准异步化的业务流程

1. 当用户要进行耗时很长的操作时，用户点击分析后，不需要在界面傻等，而是应该将这个任务保存到数据库中记录下来

2. 用户要执行新任务时：
   - **提交任务成功**：
     - 如果我们的程序还有多余的空闲线程，可以立即去做这个任务
     - 如果我们的程序都在忙，那就放到等待队列中
   - **提交任务失败**：任务队列满了
     - 拒绝这个任务，再也不执行
     - 通过保存到数据库中的记录来看到提交失败的任务，并且在程序闲的时候，可以把任务从数据库中取到程序中，再去执行
3. 我们的程序（线程）从任务队列中取出任务依次执行，完成每一件事要修改一下任务的状态

4. 用户可以查询任务的状态，或者在任务执行成功或者失败时能得到通知

5. 如果要执行的任务很复杂，包含很多环节，每一个小任务完成时，要在程序（数据库）中记录一下任务的执行状态，进度

## 系统的业务流程

1. 用户点击分析时按钮时，先把图表立刻保存到数据库中（作为一个任务）
2. 用户可以在图表管理页面查看所有图表（已生成的、生成中的、生成失败）的信息和状态
3. 用户可以修改生成失败的图表信息，点击重新生成
![img.png](img.png)

## 线程池

### 线程池的实现

`public ThreadPoolExecutor(int corePoolSize,
int maximumPoolSize,
long keepAliveTime,
TimeUnit unit,
BlockingQueue<Runnable> workQueue,
ThreadFactory threadFactory,
RejectedExecutionHandler handler)`

#### 参数说明
1. corePoolSize(核心线程数=>相当于正式员工)：正常情况下，我们的系统应该能同时工作的线程数（随时就绪状态）
2. maximumPoolSize(最大线程数=>哪怕任务再多，也只招这些人)：极限情况下，我们的线程池最多有多少个线程
3. keepAliveTime(空闲线程存活时间)：超过这个时间，多余的线程就会自动结束工作，从而释放无用的线程资源
4. TimeUnit unit(空闲线程存活时间的单位)：秒、分
5. workQueue(工作队列)：用于存放给线程执行的任务，存在一个队列的长度（一定要设置一个长度，不要说队列长度无限，因为也会占用资源）
6. threadFactory(线程工厂)：控制每个线程的生成、线程的属性（比如线程名）
7. rejectedExecutionHandler(拒绝策略)：当任务队列满时，我们采取什么措施，比如抛异常、不抛异常、自定义策略

#### 资源隔离策略
- 比如重要的任务一个队列，非重要的任务一个队列，保证这两个队列互不干扰（VIP任务、普通任务）

### 线程池参数设置

当前AI的API处理能力为4QPS，每个任务处理时间为10秒，那么线程池的参数设置如下：

| 参数 | 值 | 说明 |
|------|----|------|
| corePoolSize | 4 | 正常情况下可以设置为4 |
| maximumPoolSize | ≤4 | 考虑极限情况，不超过4 |
| keepAliveTime | 秒级或分钟级 | 多余线程的存活时间 |
| TimeUnit | TimeUnit.SECONDS | 时间单位设置为秒 |
| workQueue | 20 | 结合实际情况设置队列长度 |
| threadFactory | 自定义 | 控制线程的生成和属性（如线程名） |
| rejectedExecutionHandler | 自定义策略 | 抛异常并标记数据库任务状态为"任务满了，已拒绝" |

一般情况下，任务分为IO密集型和计算密集型两种。
- IO密集型：吃带宽、硬盘、内存的读写资源，corePoolSize可以设置大一点，一般经验值是2n左右，建议以IO的能力为主
- 计算密集型：吃CPU资源，比如音视频处理、图像处理、数学计算等，corePoolSize为CPU核数+1（空余线程），可以让每个线程都能利用好CPU的每个核，而且线程之间不用频繁切换（减少打架、开销）
- 混合型：既吃CPU又吃IO，比如爬虫、日志处理、数据库查询、网络请求等，可以设置corePoolSize为CPU核数，然后设置workQueue为有界队列，防止任务过多导致OOM

### 实现工作流程
1. 给chart表中增加任务状态字段（比如排队中、执行中、已完成、失败），任务执行信息字段（用于记录任务执行中、或者执行失败时，保存错误信息）
2. 用户可以在图表管理页面查看所有图表（已生成的、生成中的、生成失败）的信息和状态
3. 任务：先修改图表任务状态为“执行中”，等执行成功后修改为“已完成”、保存执行结果，执行失败时修改为“失败”，记录任务失败信息
4. 用户可以在图表管理页面查看所有图表（已生成、生成中、生成失败）的信息和状态

### 库表设计
```status  varchar(128) not null default 'wait' comment 'wait,running,succeed,failed',
add execMessage text null comment '执行信息';
```

任务执行逻辑
先修改任务执行状态为“执行中”，减少重复执行的风险，同时让用户指导执行状态

### 进一步优化
1. 增加重试功能（使用guava的Retrying重试）
2. 如果任务没进入队列中（或者任务队列满了），可以用定时任务把他放到队列中（补偿）